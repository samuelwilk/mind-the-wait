<?php

declare(strict_types=1);

namespace App\Tests\Service\History;

use App\Entity\ArrivalLog;
use App\Entity\Route;
use App\Entity\Stop;
use App\Entity\WeatherObservation;
use App\Enum\PredictionConfidence;
use App\Enum\RouteTypeEnum;
use App\Enum\TransitImpact;
use App\Repository\ArrivalLogRepository;
use App\Repository\RouteRepository;
use App\Repository\WeatherObservationRepository;
use App\Service\History\PerformanceAggregator;
use App\Tests\InjectableHelperTrait;
use App\Tests\CityAwareTestTrait;use Doctrine\ORM\EntityManagerInterface;
use Symfony\Bundle\FrameworkBundle\Test\KernelTestCase;

/**
 * Integration tests for PerformanceAggregator using real database.
 *
 * Uses DAMA DoctrineTestBundle for automatic transaction rollback between tests.
 */
final class PerformanceAggregatorTest extends KernelTestCase
{
    use InjectableHelperTrait;
    use CityAwareTestTrait;
    private EntityManagerInterface $em;
    private RouteRepository $routeRepo;
    private ArrivalLogRepository $arrivalLogRepo;
    private WeatherObservationRepository $weatherRepo;
    private PerformanceAggregator $aggregator;

    protected function setUp(): void
    {
        self::bootKernel(['environment' => 'test', 'debug' => true]);

        $this->em             = $this->getInjectable(EntityManagerInterface::class);
        $this->routeRepo      = $this->getInjectable(RouteRepository::class);
        $this->arrivalLogRepo = $this->getInjectable(ArrivalLogRepository::class);
        $this->weatherRepo    = $this->getInjectable(WeatherObservationRepository::class);
        $this->aggregator     = $this->getInjectable(PerformanceAggregator::class);
    }

    public function testCalculatesCorrectMedianForOddNumberOfDelays(): void
    {
        $route = $this->createRoute();
        $stop  = $this->createStop();
        $date  = new \DateTimeImmutable('2025-01-01');

        // Create 3 arrival logs with different delays
        $this->createArrivalLog($route, $stop, $date, delaySec: 10);
        $this->createArrivalLog($route, $stop, $date, delaySec: 20);
        $this->createArrivalLog($route, $stop, $date, delaySec: 30);

        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(1, $result['success']); // At least 1 route aggregated
        self::assertSame(0, $result['failed']);
    }

    public function testCalculatesCorrectMedianForEvenNumberOfDelays(): void
    {
        $route = $this->createRoute('2');
        $stop  = $this->createStop('stop-2');
        $date  = new \DateTimeImmutable('2025-01-02');

        // Create 4 arrival logs - median should be (20+30)/2 = 25
        $this->createArrivalLog($route, $stop, $date, delaySec: 10);
        $this->createArrivalLog($route, $stop, $date, delaySec: 20);
        $this->createArrivalLog($route, $stop, $date, delaySec: 30);
        $this->createArrivalLog($route, $stop, $date, delaySec: 40);

        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(1, $result['success']); // At least 1 route aggregated
        self::assertSame(0, $result['failed']);
    }

    public function testCountsConfidenceLevelsCorrectly(): void
    {
        $route = $this->createRoute('3');
        $stop  = $this->createStop('stop-3');
        $date  = new \DateTimeImmutable('2025-01-03');

        $this->createArrivalLog($route, $stop, $date, confidence: PredictionConfidence::HIGH);
        $this->createArrivalLog($route, $stop, $date, confidence: PredictionConfidence::HIGH);
        $this->createArrivalLog($route, $stop, $date, confidence: PredictionConfidence::MEDIUM);
        $this->createArrivalLog($route, $stop, $date, confidence: PredictionConfidence::LOW);

        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(1, $result['success']); // At least 1 route aggregated
        // Expected: 2 high, 1 medium, 1 low, total 4
    }

    public function testHandlesEmptyLogsGracefully(): void
    {
        // Create route with no logs
        $this->createRoute('4');
        $this->em->flush();

        $result = $this->aggregator->aggregateDate(new \DateTimeImmutable('2025-01-04'));

        // Should skip routes with no activity
        self::assertSame(0, $result['success']);
        self::assertSame(0, $result['failed']);
    }

    public function testLinksWeatherObservationFromNoontime(): void
    {
        $route       = $this->createRoute('5');
        $stop        = $this->createStop('stop-5');
        $date        = new \DateTimeImmutable('2025-01-05');
        $weatherTime = new \DateTimeImmutable('2025-01-05 12:00:05'); // Unique seconds to avoid collision

        // Create weather observation at noon using upsert to handle duplicates
        $weather = new WeatherObservation();
        $weather->setObservedAt($weatherTime);
        $weather->setTemperatureCelsius('2.4');
        $weather->setWeatherCondition('snow');
        $weather->setWeatherCode(71);
        $weather->setTransitImpact(TransitImpact::MINOR);
        $weather->setDataSource('test');
        $this->weatherRepo->upsert($weather); // Use upsert instead of persist

        $this->createArrivalLog($route, $stop, $date, delaySec: 100);
        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(1, $result['success']); // At least 1 route aggregated
    }

    public function testHandlesNullDelaysGracefully(): void
    {
        $route = $this->createRoute('6');
        $stop  = $this->createStop('stop-6');
        $date  = new \DateTimeImmutable('2025-01-06');

        // Create logs with null delay
        $this->createArrivalLog($route, $stop, $date, delaySec: null);
        $this->createArrivalLog($route, $stop, $date, delaySec: 100);
        $this->createArrivalLog($route, $stop, $date, delaySec: 200);

        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(1, $result['success']); // At least 1 route aggregated
        // Total predictions = 3, but only 2 have delay data
    }

    /**
     * REGRESSION TEST: Verify aggregation writes performance records to database correctly.
     */
    public function testAggregationWritesPerformanceRecordToDatabase(): void
    {
        $route = $this->createRoute('7');
        $stop  = $this->createStop('stop-7');
        $date  = new \DateTimeImmutable('2025-01-07');

        // Create 10 arrival logs: 5 on-time (Â±180s), 3 late (>180s), 2 early (<-180s)
        $this->createArrivalLog($route, $stop, $date, delaySec: 0);     // on-time
        $this->createArrivalLog($route, $stop, $date, delaySec: 60);    // on-time
        $this->createArrivalLog($route, $stop, $date, delaySec: -60);   // on-time
        $this->createArrivalLog($route, $stop, $date, delaySec: 150);   // on-time
        $this->createArrivalLog($route, $stop, $date, delaySec: -150);  // on-time
        $this->createArrivalLog($route, $stop, $date, delaySec: 300);   // late
        $this->createArrivalLog($route, $stop, $date, delaySec: 400);   // late
        $this->createArrivalLog($route, $stop, $date, delaySec: 500);   // late
        $this->createArrivalLog($route, $stop, $date, delaySec: -300);  // early
        $this->createArrivalLog($route, $stop, $date, delaySec: -400);  // early

        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(1, $result['success']); // At least 1 route aggregated
        self::assertSame(0, $result['failed']);

        // Verify database record was created for this specific route
        $performance = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route, 'date' => $date]);

        self::assertNotNull($performance, 'Performance record should be created in database');
        self::assertSame(10, $performance->getTotalPredictions());
        // PostgreSQL numeric type drops trailing zeros for whole numbers
        self::assertSame('50', $performance->getOnTimePercentage(), 'On-time: 5/10 = 50%');
        self::assertSame('30', $performance->getLatePercentage(), 'Late: 3/10 = 30%');
        self::assertSame('20', $performance->getEarlyPercentage(), 'Early: 2/10 = 20%');
    }

    /**
     * REGRESSION TEST: Verify upsert behavior - running aggregation twice on same date updates instead of duplicating.
     */
    public function testAggregationIsIdempotent(): void
    {
        $route = $this->createRoute('8');
        $stop  = $this->createStop('stop-8');
        $date  = new \DateTimeImmutable('2025-01-08');

        // First run: 5 logs
        $this->createArrivalLog($route, $stop, $date, delaySec: 100);
        $this->createArrivalLog($route, $stop, $date, delaySec: 200);
        $this->createArrivalLog($route, $stop, $date, delaySec: 300);
        $this->createArrivalLog($route, $stop, $date, delaySec: 400);
        $this->createArrivalLog($route, $stop, $date, delaySec: 500);
        $this->em->flush();

        $result1 = $this->aggregator->aggregateDate($date);
        self::assertGreaterThanOrEqual(1, $result1['success']); // At least 1 route aggregated

        $performance1 = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route, 'date' => $date]);
        self::assertNotNull($performance1);
        self::assertSame(5, $performance1->getTotalPredictions());

        // Second run: add 3 more logs (simulating late arrival logs)
        $this->createArrivalLog($route, $stop, $date, delaySec: 600);
        $this->createArrivalLog($route, $stop, $date, delaySec: 700);
        $this->createArrivalLog($route, $stop, $date, delaySec: 800);
        $this->em->flush();

        $result2 = $this->aggregator->aggregateDate($date);
        self::assertGreaterThanOrEqual(1, $result2['success']); // At least 1 route aggregated

        // Verify record was updated (not duplicated)
        $allPerformances = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findBy(['route' => $route, 'date' => $date]);
        self::assertCount(1, $allPerformances, 'Should have exactly 1 performance record (upsert behavior)');

        $performance2 = $allPerformances[0];
        self::assertSame(8, $performance2->getTotalPredictions(), 'Total should be updated to 8');
    }

    /**
     * REGRESSION TEST: Verify multiple routes are aggregated in one pass.
     */
    public function testAggregatesMultipleRoutesInOnePass(): void
    {
        $date = new \DateTimeImmutable('2025-01-09');

        // Create 3 routes with logs
        $route1 = $this->createRoute('9-1');
        $route2 = $this->createRoute('9-2');
        $route3 = $this->createRoute('9-3');
        $stop   = $this->createStop('stop-9');

        $this->createArrivalLog($route1, $stop, $date, delaySec: 100);
        $this->createArrivalLog($route1, $stop, $date, delaySec: 200);
        $this->createArrivalLog($route2, $stop, $date, delaySec: 300);
        $this->createArrivalLog($route2, $stop, $date, delaySec: 400);
        $this->createArrivalLog($route2, $stop, $date, delaySec: 500);
        $this->createArrivalLog($route3, $stop, $date, delaySec: 600);

        $this->em->flush();

        $result = $this->aggregator->aggregateDate($date);

        self::assertGreaterThanOrEqual(3, $result['success'], 'Should aggregate at least 3 routes');
        self::assertSame(0, $result['failed']);

        // Verify all 3 routes have performance records
        $performance1 = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route1, 'date' => $date]);
        $performance2 = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route2, 'date' => $date]);
        $performance3 = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route3, 'date' => $date]);

        self::assertNotNull($performance1, 'Route 1 should have performance record');
        self::assertNotNull($performance2, 'Route 2 should have performance record');
        self::assertNotNull($performance3, 'Route 3 should have performance record');

        self::assertSame(2, $performance1->getTotalPredictions());
        self::assertSame(3, $performance2->getTotalPredictions());
        self::assertSame(1, $performance3->getTotalPredictions());
    }

    /**
     * REGRESSION TEST: Verify all on-time scenario calculates 100% on-time, 0% late/early.
     */
    public function testAllOnTimeScenario(): void
    {
        $route = $this->createRoute('10');
        $stop  = $this->createStop('stop-10');
        $date  = new \DateTimeImmutable('2025-01-10');

        // All logs within Â±180 seconds (on-time threshold)
        $this->createArrivalLog($route, $stop, $date, delaySec: 0);
        $this->createArrivalLog($route, $stop, $date, delaySec: 60);
        $this->createArrivalLog($route, $stop, $date, delaySec: -60);
        $this->createArrivalLog($route, $stop, $date, delaySec: 120);
        $this->createArrivalLog($route, $stop, $date, delaySec: -120);

        $this->em->flush();

        $this->aggregator->aggregateDate($date);

        $performance = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route, 'date' => $date]);

        self::assertSame('100', $performance->getOnTimePercentage());
        self::assertSame('0', $performance->getLatePercentage());
        self::assertSame('0', $performance->getEarlyPercentage());
    }

    /**
     * REGRESSION TEST: Verify all late scenario calculates 0% on-time, 100% late, 0% early.
     */
    public function testAllLateScenario(): void
    {
        $route = $this->createRoute('11');
        $stop  = $this->createStop('stop-11');
        $date  = new \DateTimeImmutable('2025-01-11');

        // All logs > 180 seconds late (late threshold)
        $this->createArrivalLog($route, $stop, $date, delaySec: 200);
        $this->createArrivalLog($route, $stop, $date, delaySec: 300);
        $this->createArrivalLog($route, $stop, $date, delaySec: 400);
        $this->createArrivalLog($route, $stop, $date, delaySec: 500);

        $this->em->flush();

        $this->aggregator->aggregateDate($date);

        $performance = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route, 'date' => $date]);

        self::assertSame('0', $performance->getOnTimePercentage());
        self::assertSame('100', $performance->getLatePercentage());
        self::assertSame('0', $performance->getEarlyPercentage());
    }

    /**
     * REGRESSION TEST: Verify all early scenario calculates 0% on-time, 0% late, 100% early.
     */
    public function testAllEarlyScenario(): void
    {
        $route = $this->createRoute('12');
        $stop  = $this->createStop('stop-12');
        $date  = new \DateTimeImmutable('2025-01-12');

        // All logs < -180 seconds (early threshold)
        $this->createArrivalLog($route, $stop, $date, delaySec: -200);
        $this->createArrivalLog($route, $stop, $date, delaySec: -300);
        $this->createArrivalLog($route, $stop, $date, delaySec: -400);

        $this->em->flush();

        $this->aggregator->aggregateDate($date);

        $performance = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route, 'date' => $date]);

        self::assertSame('0', $performance->getOnTimePercentage());
        self::assertSame('0', $performance->getLatePercentage());
        self::assertSame('100', $performance->getEarlyPercentage());
    }

    /**
     * REGRESSION TEST: Verify weather observation is correctly linked to performance record.
     */
    public function testWeatherObservationLinkedInDatabase(): void
    {
        $route       = $this->createRoute('13');
        $stop        = $this->createStop('stop-13');
        $date        = new \DateTimeImmutable('2025-01-13');
        $weatherTime = new \DateTimeImmutable('2025-01-13 12:00:13'); // Unique seconds to avoid collision

        // Create weather observation at noon using upsert to handle duplicates
        $weather = new WeatherObservation();
        $weather->setObservedAt($weatherTime);
        $weather->setTemperatureCelsius('-15.5');
        $weather->setWeatherCondition('snow');
        $weather->setWeatherCode(71);
        $weather->setTransitImpact(TransitImpact::MODERATE);
        $weather->setDataSource('test');
        $this->weatherRepo->upsert($weather); // Use upsert instead of persist

        $this->createArrivalLog($route, $stop, $date, delaySec: 100);
        $this->em->flush();

        $this->aggregator->aggregateDate($date);

        $performance = $this->em->getRepository(\App\Entity\RoutePerformanceDaily::class)
            ->findOneBy(['route' => $route, 'date' => $date]);

        self::assertNotNull($performance->getWeatherObservation(), 'Weather observation should be linked');
        self::assertSame('-15.5', $performance->getWeatherObservation()->getTemperatureCelsius());
        self::assertSame('snow', $performance->getWeatherObservation()->getWeatherCondition());
        self::assertSame(TransitImpact::MODERATE, $performance->getWeatherObservation()->getTransitImpact());
    }

    private function createRoute(string $gtfsId = '1'): Route
    {
        $route = new Route();
        $route->setGtfsId($gtfsId);
        $route->setShortName($gtfsId);
        $route->setLongName('Test Route '.$gtfsId);
        $route->setRouteType(RouteTypeEnum::Bus);
        $route->setCity($this->getTestCity($this->em));
        $this->em->persist($route);

        return $route;
    }

    private function createStop(string $gtfsId = 'stop-1'): Stop
    {
        $stop = new Stop();
        $stop->setGtfsId($gtfsId);
        $stop->setName('Test Stop '.$gtfsId);
        $stop->setLat(52.1324);
        $stop->setLong(-106.6607);
        $this->em->persist($stop);

        return $stop;
    }

    private function createArrivalLog(
        Route $route,
        Stop $stop,
        \DateTimeImmutable $date,
        ?int $delaySec = 0,
        PredictionConfidence $confidence = PredictionConfidence::HIGH,
    ): ArrivalLog {
        $log = new ArrivalLog();
        $log->setRoute($route);
        $log->setStop($stop);
        $log->setVehicleId('veh-test-'.random_int(1000, 9999));
        $log->setTripId('trip-test-'.random_int(1000, 9999));
        $log->setPredictedArrivalAt($date);
        $log->setPredictedAt($date);
        $log->setConfidence($confidence);
        $log->setDelaySec($delaySec);
        $this->em->persist($log);

        return $log;
    }
}
