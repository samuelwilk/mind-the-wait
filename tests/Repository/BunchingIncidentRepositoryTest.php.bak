<?php

declare(strict_types=1);

namespace App\Tests\Repository;

use App\Dto\BunchingCountDto;
use App\Entity\BunchingIncident;
use App\Entity\Route;
use App\Entity\Stop;
use App\Entity\WeatherObservation;
use App\Enum\TransitImpact;
use App\Repository\BunchingIncidentRepository;
use PHPUnit\Framework\Attributes\CoversClass;
use PHPUnit\Framework\TestCase;

use const PHP_FLOAT_MAX;

#[CoversClass(BunchingIncidentRepository::class)]
final class BunchingIncidentRepositoryTest extends TestCase
{
    /**
     * Test that countByWeatherCondition groups incidents correctly.
     */
    public function testCountByWeatherConditionGroupsCorrectly(): void
    {
        $startDate = new \DateTimeImmutable('2025-01-01');
        $endDate   = new \DateTimeImmutable('2025-02-01');

        // Simulate database results: each incident linked to a weather condition
        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Snow'),
            $this->createIncident('2025-01-05 11:00:00', 'Snow'),
            $this->createIncident('2025-01-05 12:00:00', 'Snow'),
            $this->createIncident('2025-01-10 14:00:00', 'Rain'),
            $this->createIncident('2025-01-15 16:00:00', 'Rain'),
            $this->createIncident('2025-01-20 18:00:00', 'Clear'),
        ];

        // Count by weather condition
        $counts = $this->groupByWeatherCondition($incidents);

        $this->assertCount(3, $counts, 'Should have 3 unique weather conditions');
        $this->assertEquals('Snow', $counts[0]->weatherCondition);
        $this->assertEquals(3, $counts[0]->incidentCount);
        $this->assertEquals('Rain', $counts[1]->weatherCondition);
        $this->assertEquals(2, $counts[1]->incidentCount);
        $this->assertEquals('Clear', $counts[2]->weatherCondition);
        $this->assertEquals(1, $counts[2]->incidentCount);
    }

    /**
     * Test that countByWeatherCondition filters by date range.
     */
    public function testCountByWeatherConditionFiltersDateRange(): void
    {
        // Only include incidents within date range
        $startDate = new \DateTimeImmutable('2025-01-10');
        $endDate   = new \DateTimeImmutable('2025-01-20');

        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Snow'), // Before range (excluded)
            $this->createIncident('2025-01-15 11:00:00', 'Snow'), // In range
            $this->createIncident('2025-01-25 12:00:00', 'Rain'), // After range (excluded)
        ];

        // Filter incidents within date range
        $filtered = array_filter(
            $incidents,
            fn ($i) => $i->getDetectedAt() >= $startDate && $i->getDetectedAt() < $endDate
        );

        $counts = $this->groupByWeatherCondition($filtered);

        $this->assertCount(1, $counts, 'Should only include incidents within date range');
        $this->assertEquals('Snow', $counts[0]->weatherCondition);
        $this->assertEquals(1, $counts[0]->incidentCount);
    }

    /**
     * Test that countByWeatherCondition excludes null weather conditions.
     */
    public function testCountByWeatherConditionExcludesNullWeather(): void
    {
        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Snow'),
            $this->createIncident('2025-01-10 11:00:00', null), // No weather data
            $this->createIncident('2025-01-15 12:00:00', 'Rain'),
        ];

        // Filter out incidents without weather observation
        $filtered = array_filter($incidents, fn ($i) => $i->getWeatherObservation() !== null);

        $counts = $this->groupByWeatherCondition($filtered);

        $this->assertCount(2, $counts, 'Should exclude incidents with null weather');
        $this->assertEquals('Snow', $counts[0]->weatherCondition);
        $this->assertEquals('Rain', $counts[1]->weatherCondition);
    }

    /**
     * Test that countByWeatherCondition orders by incident count descending.
     */
    public function testCountByWeatherConditionOrdersByCountDescending(): void
    {
        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Clear'),
            $this->createIncident('2025-01-05 11:00:00', 'Rain'),
            $this->createIncident('2025-01-05 12:00:00', 'Rain'),
            $this->createIncident('2025-01-05 13:00:00', 'Snow'),
            $this->createIncident('2025-01-05 14:00:00', 'Snow'),
            $this->createIncident('2025-01-05 15:00:00', 'Snow'),
            $this->createIncident('2025-01-05 16:00:00', 'Snow'),
        ];

        $counts = $this->groupByWeatherCondition($incidents);

        // Verify ordering: Snow (4) > Rain (2) > Clear (1)
        $this->assertEquals('Snow', $counts[0]->weatherCondition);
        $this->assertEquals(4, $counts[0]->incidentCount);
        $this->assertEquals('Rain', $counts[1]->weatherCondition);
        $this->assertEquals(2, $counts[1]->incidentCount);
        $this->assertEquals('Clear', $counts[2]->weatherCondition);
        $this->assertEquals(1, $counts[2]->incidentCount);
    }

    /**
     * Test that countByWeatherCondition returns empty array when no incidents.
     */
    public function testCountByWeatherConditionReturnsEmptyArrayWhenNoIncidents(): void
    {
        $incidents = [];

        $counts = $this->groupByWeatherCondition($incidents);

        $this->assertCount(0, $counts, 'Should return empty array when no incidents');
    }

    /**
     * Test that countByWeatherCondition handles multiple incidents with same condition.
     */
    public function testCountByWeatherConditionAggregatesSameConditions(): void
    {
        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Snow'),
            $this->createIncident('2025-01-05 11:00:00', 'Snow'),
            $this->createIncident('2025-01-05 12:00:00', 'Snow'),
            $this->createIncident('2025-01-05 13:00:00', 'Snow'),
            $this->createIncident('2025-01-05 14:00:00', 'Snow'),
        ];

        $counts = $this->groupByWeatherCondition($incidents);

        $this->assertCount(1, $counts, 'Should aggregate all incidents into one group');
        $this->assertEquals('Snow', $counts[0]->weatherCondition);
        $this->assertEquals(5, $counts[0]->incidentCount);
    }

    /**
     * Test that countByWeatherCondition preserves exact weather condition strings.
     */
    public function testCountByWeatherConditionPreservesWeatherConditionCase(): void
    {
        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Heavy Snow'),
            $this->createIncident('2025-01-05 11:00:00', 'Light Rain'),
            $this->createIncident('2025-01-05 12:00:00', 'Overcast'),
        ];

        $counts = $this->groupByWeatherCondition($incidents);

        $this->assertEquals('Heavy Snow', $counts[0]->weatherCondition);
        $this->assertEquals('Light Rain', $counts[1]->weatherCondition);
        $this->assertEquals('Overcast', $counts[2]->weatherCondition);
    }

    /**
     * Test findByDateRange filters and orders correctly.
     */
    public function testFindByDateRangeFiltersAndOrders(): void
    {
        $startDate = new \DateTimeImmutable('2025-01-10');
        $endDate   = new \DateTimeImmutable('2025-01-20');

        $incidents = [
            $this->createIncident('2025-01-05 10:00:00', 'Snow'), // Before range
            $this->createIncident('2025-01-12 11:00:00', 'Rain'), // In range
            $this->createIncident('2025-01-15 12:00:00', 'Snow'), // In range
            $this->createIncident('2025-01-11 13:00:00', 'Clear'), // In range
            $this->createIncident('2025-01-25 14:00:00', 'Rain'), // After range
        ];

        // Filter incidents within date range
        $filtered = array_filter(
            $incidents,
            fn ($i) => $i->getDetectedAt() >= $startDate && $i->getDetectedAt() < $endDate
        );

        // Sort by detected_at ascending
        usort($filtered, fn ($a, $b) => $a->getDetectedAt() <=> $b->getDetectedAt());

        $this->assertCount(3, $filtered, 'Should include only incidents within date range');
        $this->assertEquals('2025-01-11', $filtered[0]->getDetectedAt()->format('Y-m-d'));
        $this->assertEquals('2025-01-12', $filtered[1]->getDetectedAt()->format('Y-m-d'));
        $this->assertEquals('2025-01-15', $filtered[2]->getDetectedAt()->format('Y-m-d'));
    }

    /**
     * Test save method persists incident.
     */
    public function testSaveMethodPersistsIncident(): void
    {
        $incident = $this->createIncident('2025-01-05 10:00:00', 'Snow');

        // In real implementation, this would call EntityManager::persist()
        // For unit test, we just verify the incident object is valid
        $this->assertInstanceOf(BunchingIncident::class, $incident);
        $this->assertEquals('Snow', $incident->getWeatherObservation()?->getWeatherCondition());
        $this->assertEquals(2, $incident->getVehicleCount());
        $this->assertEquals(120, $incident->getTimeWindowSeconds());
    }

    /**
     * Simulate grouping and counting logic from countByWeatherCondition.
     *
     * @param list<BunchingIncident> $incidents
     *
     * @return list<BunchingCountDto>
     */
    private function groupByWeatherCondition(array $incidents): array
    {
        // Group by weather condition
        $grouped = [];
        foreach ($incidents as $incident) {
            $weather = $incident->getWeatherObservation();
            if ($weather === null) {
                continue;
            }

            $condition = $weather->getWeatherCondition();
            if (!isset($grouped[$condition])) {
                $grouped[$condition] = 0;
            }
            ++$grouped[$condition];
        }

        // Convert to DTOs
        $results = [];
        foreach ($grouped as $condition => $count) {
            $results[] = new BunchingCountDto(
                weatherCondition: $condition,
                incidentCount: $count,
            );
        }

        // Sort by count descending
        usort($results, fn ($a, $b) => $b->incidentCount <=> $a->incidentCount);

        return $results;
    }

    /**
     * Test countByWeatherConditionNormalized returns correct structure.
     *
     * Note: This is a structural test. Integration tests validate the actual SQL logic.
     */
    public function testCountByWeatherConditionNormalizedReturnsCorrectStructure(): void
    {
        // Simulate the expected output structure from countByWeatherConditionNormalized
        $mockResults = [
            [
                'weather_condition'  => 'Snow',
                'incident_count'     => 100,
                'exposure_hours'     => 72.0,
                'incidents_per_hour' => 1.39,
            ],
            [
                'weather_condition'  => 'Clear',
                'incident_count'     => 200,
                'exposure_hours'     => 576.0,
                'incidents_per_hour' => 0.35,
            ],
        ];

        // Validate structure of each result
        foreach ($mockResults as $result) {
            $this->assertArrayHasKey('weather_condition', $result);
            $this->assertArrayHasKey('incident_count', $result);
            $this->assertArrayHasKey('exposure_hours', $result);
            $this->assertArrayHasKey('incidents_per_hour', $result);

            $this->assertIsString($result['weather_condition']);
            $this->assertIsInt($result['incident_count']);
            $this->assertIsFloat($result['exposure_hours']);
            $this->assertIsFloat($result['incidents_per_hour']);

            // Validate calculation: incidents_per_hour = incident_count / exposure_hours
            if ($result['exposure_hours'] > 0) {
                $expectedRate = $result['incident_count'] / $result['exposure_hours'];
                $this->assertEqualsWithDelta(
                    $expectedRate,
                    $result['incidents_per_hour'],
                    0.01,
                    'Rate calculation should be correct'
                );
            }
        }
    }

    /**
     * Test countByWeatherConditionNormalized handles zero exposure hours.
     */
    public function testCountByWeatherConditionNormalizedExcludesZeroExposure(): void
    {
        // Mock results should not include conditions with zero exposure hours
        // The WHERE clause in SQL filters these out
        $mockResults = [
            [
                'weather_condition'  => 'Snow',
                'incident_count'     => 10,
                'exposure_hours'     => 24.0,
                'incidents_per_hour' => 0.42,
            ],
        ];

        // All results should have exposure_hours > 0
        foreach ($mockResults as $result) {
            $this->assertGreaterThan(0, $result['exposure_hours'], 'No zero-exposure conditions should be returned');
        }
    }

    /**
     * Test countByWeatherConditionNormalized orders by incidents_per_hour descending.
     */
    public function testCountByWeatherConditionNormalizedOrdersByRateDescending(): void
    {
        // Mock results ordered by incidents_per_hour (descending)
        $mockResults = [
            [
                'weather_condition'  => 'Snow',
                'incident_count'     => 50,
                'exposure_hours'     => 10.0,
                'incidents_per_hour' => 5.00, // Highest rate
            ],
            [
                'weather_condition'  => 'Rain',
                'incident_count'     => 30,
                'exposure_hours'     => 20.0,
                'incidents_per_hour' => 1.50,
            ],
            [
                'weather_condition'  => 'Clear',
                'incident_count'     => 100,
                'exposure_hours'     => 200.0,
                'incidents_per_hour' => 0.50, // Lowest rate
            ],
        ];

        // Verify ordering
        $previousRate = PHP_FLOAT_MAX;
        foreach ($mockResults as $result) {
            $this->assertLessThanOrEqual($previousRate, $result['incidents_per_hour'], 'Results should be ordered by rate descending');
            $previousRate = $result['incidents_per_hour'];
        }
    }

    private function createIncident(string $dateTime, ?string $weatherCondition): BunchingIncident
    {
        $route = new Route();
        $route->setGtfsId('route-1');
        $route->setShortName('1');
        $route->setLongName('Test Route');
        $route->setColour('FF0000');

        $stop = new Stop();
        $stop->setGtfsId('stop-1');
        $stop->setName('Test Stop');
        $stop->setLat(52.1332);
        $stop->setLong(-106.6700);
        $stop->setCity($this->getTestCity($this->em));

        $incident = new BunchingIncident();
        $incident->setRoute($route);
        $incident->setStop($stop);
        $incident->setDetectedAt(new \DateTimeImmutable($dateTime));
        $incident->setVehicleCount(2);
        $incident->setTimeWindowSeconds(120);
        $incident->setVehicleIds('veh-1,veh-2');

        if ($weatherCondition !== null) {
            $weather = new WeatherObservation();
            $weather->setObservedAt(new \DateTimeImmutable($dateTime));
            $weather->setWeatherCondition($weatherCondition);
            $weather->setWeatherCode(0);
            $weather->setTemperatureCelsius('0.0');
            $weather->setTransitImpact(TransitImpact::NONE);
            $weather->setDataSource('test');
            $incident->setWeatherObservation($weather);
        }

        return $incident;
    }
}
